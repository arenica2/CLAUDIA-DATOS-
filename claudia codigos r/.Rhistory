cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & grepl("P.",cons2006_2009$OBSERVACIONES, fixed = TRUE)] <- 5 #"LP"
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & (grepl("V.",cons2006_2009$OBSERVACIONES, fixed = TRUE) | grepl("LOTE VACIO",cons2006_2009$OBSERVACIONES))] <- 6 #"LV"
#Si STATUS = NA y contiene la palabra "CONSTRUCCICN" o "NO SE ROCIO" ponemos C
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & (grepl("CONSTRUCCICN",cons2006_2009$OBSERVACIONES) | grepl("NO SE ROCIO",cons2006_2009$OBSERVACIONES))] <- 3 #"C"
#Si STATUS = NA y contiene la palabra "FUE ROCIADA"
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & grepl("FUE ROCIADA",cons2006_2009$OBSERVACIONES)] <- 1 #"T"
#Viviendas que tienen dos UNICODEs
cons2006_2009$STATUS["1.7.25.193"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 183 es T
cons2006_2009$STATUS["1.7.25.236"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 194 es T
cons2006_2009$STATUS["1.7.41.199"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 200 es T
cons2006_2009$STATUS["1.7.41.238"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 237 es T
cons2006_2009$STATUS["1.7.41.292"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 291 es T
cons2006_2009$STATUS["1.7.8A.357"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 356 es T
cons2006_2009$STATUS["1.7.41.238"== cons2006_2009$UNICODE & 2==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 237 es T
cons2006_2009$STATUS["1.7.48C.15"== cons2006_2009$UNICODE & 2==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 12 es T
#NOTA: Quedan 6 UNICODEs con NA en la columna STATUS
#------------------------------------------------------------------------------
#Creando la columna POS_CHIRI
cons2006_2009$POS_CHIRI[1==cons2006_2009$I_TRIAT | 1==cons2006_2009$P_TRIAT] <- 1
cons2006_2009$POS_CHIRI[is.na(cons2006_2009$POS_CHIRI)] <- 0
#Seleccionando solo las columna UNICODE, CICLO, STATUS y POS_CHIRI
status_cons2006_2009 <- subset(cons2006_2009, select = c(UNICODE, CICLO_ROCIADO, STATUS, POS_CHIRI))
status_cons2006_2009 <- unique(status_cons2006_2009)
#Utilizando funcion ElimDupliUxS()
c1_cons2006_2009 <- ElimDupliUxS(status_cons2006_2009[1 == status_cons2006_2009$CICLO_ROCIADO,])
c2_cons2006_2009 <- ElimDupliUxS(status_cons2006_2009[2 == status_cons2006_2009$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
status_cons2006_2009 <- rbind(c1_cons2006_2009, c2_cons2006_2009)
#----
#Acomodando los datos del consolidado 2009-2015 MINSA
#Creando la columna STATUS
CONS_ROCIADO_2009_2015$STATUS <- "T"
#Creando columna POS_CHIRI
CONS_ROCIADO_2009_2015$POS_CHIRI[is.na(CONS_ROCIADO_2009_2015$IN_TRI) & is.na(CONS_ROCIADO_2009_2015$PE_TRI)] <- 0
CONS_ROCIADO_2009_2015$POS_CHIRI[is.na(CONS_ROCIADO_2009_2015$POS_CHIRI)] <- 1
C_R_D_LP_LV$POS_CHIRI <- 0
#Seleccionando solo las columnas "UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"
status_T <- subset(CONS_ROCIADO_2009_2015, select = c("UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"))
status_C_R_D_LP_LV <- subset(C_R_D_LP_LV, select = c("UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"))
#Juntando consolidado 2009 - 2015
status_cons2009_2015 <- rbind(status_T, status_C_R_D_LP_LV)
#Registros unicos
status_cons2009_2015 <- unique(status_cons2009_2015)
#Cambiando el STATUS de letras (T, R, C, etct) por numeros de orden de prioridad (T=1, R=2, C=3, etc)
status_cons2009_2015$STATUS["T"==status_cons2009_2015$STATUS] <- 1
status_cons2009_2015$STATUS["R"==status_cons2009_2015$STATUS] <- 2
status_cons2009_2015$STATUS["C"==status_cons2009_2015$STATUS] <- 3
status_cons2009_2015$STATUS["DES"==status_cons2009_2015$STATUS] <- 4
status_cons2009_2015$STATUS["LP"==status_cons2009_2015$STATUS] <- 5
status_cons2009_2015$STATUS["LV"==status_cons2009_2015$STATUS] <- 6
#Utilizando funcion ElimDupliUxS()
c1_cons2009_2015 <- ElimDupliUxS(status_cons2009_2015[1 == status_cons2009_2015$CICLO_ROCIADO,])
c2_cons2009_2015 <- ElimDupliUxS(status_cons2009_2015[2 == status_cons2009_2015$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
status_cons2009_2015 <- rbind(c1_cons2009_2015, c2_cons2009_2015)
#-----
#CONSOLIDADO COMPLETO DESDE EL 2006 HASTA 2015 DEL MINSA CON LAS COLUMNAS: UNICODE, CICLO_ROCIADO, STATUS, POS_CHIRI
#Juntando consolidado final
STATUS_CONS_2006_2015 <- rbind(status_cons2006_2009, status_cons2009_2015) #181941
#Registros unicos
STATUS_CONS_2006_2015 <- unique(STATUS_CONS_2006_2015) # 181416, se eliminaron #525
#Utilizando funcion ElimDupliUxS()
c1_cons2006_2015 <- ElimDupliUxS(STATUS_CONS_2006_2015[1==STATUS_CONS_2006_2015$CICLO_ROCIADO,])
c2_cons2006_2015 <- ElimDupliUxS(STATUS_CONS_2006_2015[2==STATUS_CONS_2006_2015$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
STATUS_CONS_2006_2015 <- rbind(c1_cons2006_2015, c2_cons2006_2015) #181245: se eliminaron 171 registros duplicados
#Cambiando los valores de la columna STATUS por T,R,C,DES,LP,LV para que no haya confusiones
STATUS_CONS_2006_2015$STATUS[1==STATUS_CONS_2006_2015$STATUS] <- "T"
STATUS_CONS_2006_2015$STATUS[2==STATUS_CONS_2006_2015$STATUS] <- "R"
STATUS_CONS_2006_2015$STATUS[3==STATUS_CONS_2006_2015$STATUS] <- "C"
STATUS_CONS_2006_2015$STATUS[4==STATUS_CONS_2006_2015$STATUS] <- "DES"
STATUS_CONS_2006_2015$STATUS[5==STATUS_CONS_2006_2015$STATUS] <- "LP"
STATUS_CONS_2006_2015$STATUS[6==STATUS_CONS_2006_2015$STATUS] <- "LV"
#Separando por ciclos para poder poner cambiar los nombres de los campos
c1_cons2006_2015 <- STATUS_CONS_2006_2015[1==STATUS_CONS_2006_2015$CICLO_ROCIADO,]
c2_cons2006_2015 <- STATUS_CONS_2006_2015[2==STATUS_CONS_2006_2015$CICLO_ROCIADO,]
#Cambiando los nombres de los campos dependiendo del ciclo al que pertenecen
colnames(c1_cons2006_2015) <- c("UNICODE", "C1" , "C1_STATUS", "C1_POS_CHIRI")
colnames(c2_cons2006_2015) <- c("UNICODE", "C2" , "C2_STATUS", "C2_POS_CHIRI")
#Cambiando el valor de la columna C2 por 1=Presencia o O=Ausencia
c2_cons2006_2015$C2 <- 1
#Juntando los dos ciclos en un solo registro
STATUS_CONS_2006_2015 <- merge(c1_cons2006_2015, c2_cons2006_2015, by = "UNICODE", all = TRUE)
#Ordenando por UNICODE
STATUS_CONS_2006_2015 <- STATUS_CONS_2006_2015[order(STATUS_CONS_2006_2015$UNICODE),]
#----------------------------------------------------------------------------------------
# Imprimiendo datos
#----------------------------------------------------------------------------------------
setwd("/home/gianfranco/Documentos/github/Participation/bd_minsa/resultados")
write.csv(STATUS_CONS_2006_2015,'STATUS_CONS_2006_2015.csv')
write.csv(CONS_ROCIADO_2009_2015,'CONS_ROCIADO_2009_2015.csv')
write.csv(statusMinsaASA,'statusMinsaASA.csv')
write.csv(tratadas_ASA,'tratadas_ASA.csv')
ruta_1 <- '~/bd_minsa/bd'
#-------------------------------------------------------------------
#============ Funcion CreateUnicode =========================================
# Solo si la data tiene la columna "CODCNSLDD"
#--------------------------------------------------------------------
CreateUnicode<-function(data) {
#Esta funcion retorna un data frame con los con el UNICODE
#
#ARGS
# data = La base donde se desea obtener el UNICODE
ruta_1 <- '~/bd_minsa/bd'
#-------------------------------------------------------------------
#============ Funcion CreateUnicode =========================================
# Solo si la data tiene la columna "CODCNSLDD"
#--------------------------------------------------------------------
CreateUnicode<-function(data) {
#Esta funcion retorna un data frame con los con el UNICODE
#
#ARGS
# data = La base donde se desea obtener el UNICODE
#
#RETURNS
# data = Con las columnas UNICODE, P, D, L, V al inicio del dataframe
#
#Separando en "P", "D", "L" y "V"
data$P<-substr(data$CODCNSLDD,1,1)
data$D<-substr(data$CODCNSLDD,2,3)
data$L<-substr(data$CODCNSLDD,4,5)
data$V<-data$CODIGO
#Eliminado espacios en blanco
data$D <- gsub(" ","",data$D, fixed = T)
data$L <- gsub(" ","",data$L, fixed = T)
#Contruyendo UNICODE
data$UNICODE<-paste(data$P, data$D, data$L, data$V, sep = ".")
#Ordenando Las columnas
n_col <- length(data)
data <- data[, c(n_col, n_col-4,n_col-3,n_col-2,n_col-1, 1:(n_col-5) )]
return(data)
}
#=========================================================================
#----------------------------------------------------------------------------
#============ Funcion ELIMINAR DUPLICADOS UNICODE X STATUS ==================
# Requerimientos:
#   - Las bases de datos deben contener las columna "UNICODE", "STATUS", "POS_CHIRI"
#--------------------------------------------------------------------
ElimDupliUxS<-function(data) {
#Esta funcion retorna un data frame con los datos de unicode UNICOS poniendo en prioridad el STATUS de las viviendas
#("T", "R", "C", "DES", "LP", "LV"), para con esto seleccionar el duplicado que debe quedar en el data.frame de respuesta
#
#ARGS
# data = Data frame conteniendo los datos
#RETURNS
# data_sindupli = Data frame sin duplicados
#
uni_dupli <- unique(data$UNICODE[which(duplicated(data$UNICODE))])
#Almacenamos en una variable los datos que NO contienen UNICODEs duplicados
#Obtenemos en un array todos los UNICODEs que son duplicados
#
data_sindupli <- data[!(data$UNICODE %in% uni_dupli),]
#Almacenamos en una variable todos los registros que SI son duplicados
data_condupli <- data[data$UNICODE %in% uni_dupli,]
variable <- data_condupli[1 == data_condupli$STATUS & 1 == data_condupli$POS_CHIRI,]
#Juntamos solo las viviendas sin duplicados, dependiendo de la prioridad del STATUS (T, R, C, DES, LP, LV)
i <- 1
#Almacenamos los datos sin duplicados
data_sindupli <- rbind(data_sindupli,variable)
#Actualizando variables
x <- data[data$UNICODE %in% uni_dupli,]
data_condupli <- data_condupli[data_condupli$UNICODE %in% uni_dupli,]
variable <- data_condupli[i == data_condupli$STATUS,]
}
return(data_sindupli)
}
#install.packages (b foreignb ) #Instalar el paquete que nos permite abrir archivos ".dbf"
#Ruta
setwd(ruta_1)
t_dist<- read.csv(path.expand("~/claudia codigos r/t_dist.csv"))#contiene los cC3digos y nombre de distritos, formulacion de insecticida
t_loc<- read.csv(path.expand("~/claudia codigos r/t_loc.csv"))#contiene nombre de localidades, codigo distrito, y nro de viv total de las loc
t_roc<- read.csv(path.expand("~/claudia codigos r/t_roc.csv"))#contiene cC3digos y nombres de los rociadores
#Obtenemos las bases que nos interesan
#Dando prioridad a los UNICODEs que son tratadas(STATUS=1) y positivas (POS_CHIRI=1)
while (length(uni_dupli)) {
#Trabajamos con los duplicados
uni_dupli <- setdiff(uni_dupli, variable$UNICODE)
#=========================================================================
i <- i+1
library(foreign) #Llamando al paquete
library(foreign) #Llamando al paquete
t_mat<- read.csv(path.expand("~/claudia codigos r/t_mat.csv"))#contiene el cC3digo y el nombre de los materiales de las viviendas
td_cnsldd<- read.csv(path.expand("~/claudia codigos r/td_cnsldd.csv"))#tabla de consolidaciC3n donde se encuentra la mayorC-a de la informaciC3n
th_cnsldd<- read.csv(path.expand("~/claudia codigos r/th_cnsldd.csv"))#contiene las fechas de rociado de las viviendas, ciclo de rociado
#Eliminando inconsistencias en bases foxpro
setwd ("~/CLAUDIA-DATOS-/claudia codigos r")
library(dplyr)
library(data.table)
library(dplyr)
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
ATTACK_2006_2015<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/generalRociadoPA_Claudia_06feb.csv")
ATTACK_2006_2015<-as.data.table(ATTACK_2006_2015)
ATTACK_2006_2015[D == "5" & L== "23",L:= "22"]
library(data.table)
ATTACK_2006_2015<-as.data.table(ATTACK_2006_2015)
ATTACK_2006_2015[D == "5" & L== "23",L:= "22"]
setnames(ATTACK_2006_2015,"PE_TRI","P_TRIAT")
setnames(ATTACK_2006_2015,"IN_TRI","I_TRIAT")
setnames(ATTACK_2006_2015,"Residual_T","TRATADA")
setnames(ATTACK_2006_2015,"Residual_R","RENUENTE")
setnames(ATTACK_2006_2015,"Residual_C","CERRADA")
setnames(ATTACK_2006_2015,"Residual_D","DESHABITADA")
setnames(ATTACK_2006_2015,"Residual_LP","LOCAL_PUBLICO")
setnames(ATTACK_2006_2015,"Residual_LV","LOTE_VACIO")
setnames(ATTACK_2006_2015,"CICLO_ROCIADO","CICLO")
ATTACK_2006_2015<-as.data.frame(ATTACK_2006_2015)
varstokeep <- c("UNICODE","P","D","L","V", "P_TRIAT", "I_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")
ATTACK_2006_2015 <- ATTACK_2006_2015[,varstokeep]
View(ATTACK_2006_2015)
library(spatialEco)
library(sp)
library(dplyr)
library(data.table)
#-RUTAS UTILIZADAS
ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r/'
#Ruta
setwd(ruta_1)
#Leer los archivos
#Base de datos CONSOLIDADO GENERAL TODOS LOS DISTRITOS 2006-2015
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
#LEYENDO LOS ARCHIVOS QUE CONTIENES LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/CLAUDIA-DATOS-/AQP_GPS_GOOGLE_18_02_2017/AQP_GPS_GOOGLE_corregido.csv")
casas_aqp_adicionadas <- read.csv("~/CLAUDIA-DATOS-/claudia codigos r/added_aqp_2006_2015.csv")
nc_HUNTER<-read.csv("~/CLAUDIA-DATOS-/Hunter_Mz_06FEB2017.csv")
nc_HUNTER[nc_HUNTER==" "]<-"NA"
View(nc_HUNTER)
attack_HUNTER <- attack[(1==attack$P & 7==attack$D),]
#Seleccionando solo los campos que necesito
attack_HUNTER <- attack_HUNTER[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
casas_aqp_total<-rbind(casas_aqp,casas_aqp_adicionadas)
#Verificar si hay duplicados
indice_dupli <- casas_aqp[which(duplicated(casas_aqp$UNICODE)),1]
duplicados<-casas_aqp[casas_aqp$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
indice_dupli <- casas_aqp[which(duplicated(casas_aqp$UNICODE)),1]
duplicados<-casas_aqp[casas_aqp$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
indice_dupli <- casas_aqp_total[which(duplicated(casas_aqp_total$UNICODE)),1]
duplicados<-casas_aqp_total[casas_aqp_total$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
casas_aqp_total<-casas_aqp_total[!duplicated(casas_aqp_total$UNICODE), ]
indice_dupli <- casas_aqp_total[which(duplicated(casas_aqp_total$UNICODE)),1]
duplicados<-casas_aqp_total[casas_aqp_total$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
nc_polygon <- nc_HUNTER
old_casa_aqp <- casas_aqp_total
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
while (i <= n_row) {
i<-1 #Controlador del bucle
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
x<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
y<-NULL
#Almacenando distrito y localidad
#Inicializando los puntos del poligono
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuarÃ¡ el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
}
} else {
i<-i+1
}
inicio <-1
}
#aux_null <- 0
}
}
i<-i+1
}
library(spatialEco)
library(sp)
library(dplyr)
library(data.table)
#-RUTAS UTILIZADAS
ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r/'
#Ruta
setwd(ruta_1)
#Leer los archivos
#Base de datos CONSOLIDADO GENERAL TODOS LOS DISTRITOS 2006-2015
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
#LEYENDO LOS ARCHIVOS QUE CONTIENES LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/CLAUDIA-DATOS-/AQP_GPS_GOOGLE_18_02_2017/AQP_GPS_GOOGLE_corregido.csv")
casas_aqp_adicionadas <- read.csv("~/CLAUDIA-DATOS-/claudia codigos r/added_aqp_2006_2015.csv")
nc_HUNTER<-read.csv("~/CLAUDIA-DATOS-/Hunter_Mz_06FEB2017.csv")
nc_HUNTER[nc_HUNTER==" "]<-"NA"
attack_HUNTER <- attack[(1==attack$P & 7==attack$D),]
#Seleccionando solo los campos que necesito
attack_HUNTER <- attack_HUNTER[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
casas_aqp_total<-rbind(casas_aqp,casas_aqp_adicionadas)
#Verificar si hay duplicados
indice_dupli <- casas_aqp[which(duplicated(casas_aqp$UNICODE)),1]
duplicados<-casas_aqp[casas_aqp$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
indice_dupli <- casas_aqp_total[which(duplicated(casas_aqp_total$UNICODE)),1]
duplicados<-casas_aqp_total[casas_aqp_total$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
#Eliminando duplicados
#AUX<-casas_aqp_total[duplicated(casas_aqp_total$UNICODE), ]
casas_aqp_total<-casas_aqp_total[!duplicated(casas_aqp_total$UNICODE), ]
# casas_aqp_total<-distinct(casas_aqp_total)
#casas_aqp_total[duplicated(casas_aqp_total)]
#casas_aqp_total[!duplicated(casas_aqp_total)]
#Bases utilizadas en el proceso
nc_polygon <- nc_HUNTER
old_casa_aqp <- casas_aqp_total
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux$block <- NA
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuarÃ¡ el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
#--------JUNTANDO CONSOLIDADO CON CUADRAS -----
View(no_block)
diff1<-setdiff(attack_HUNTER$UNICODE,aqp_gps_block$UNICODE) # 136 viviendas las que etsan en el ataque pero no tenemos puntos
diff2<-setdiff(aqp_gps_block$UNICODE,attack_HUNTER$UNICODE) # 609 viviendas que hay aqp_block
#Interseccion
interseption<-intersect(attack_HUNTER$UNICODE, aqp_gps_block$UNICODE)#10365
HUNTER_gps_rociado <- merge(aqp_gps_block,attack_HUNTER, all= TRUE, by = "UNICODE")
#Comprobando
aux1 <- attack_HUNTER[attack_HUNTER$UNICODE%in%diff1,]#147 VIVIENDAS
aux2 <- HUNTER_gps_rociado[HUNTER_gps_rociado$UNICODE%in%diff1,]
aux3 <- HUNTER_gps_rociado[HUNTER_gps_rociado$UNICODE%in%diff2,]#609
View(aux1)
View(aux1)
View(HUNTER_gps_rociado)
View(aux1)
View(no_block)
