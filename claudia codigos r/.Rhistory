old_casa_aqp <- casas_aqp
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(nc_polygon)
nc_PAUCARPATA<-read.csv("~/Downloads/Paucarpata_Mz_26JUN2017 (1).csv",sep = ';')
nc_PAUCARPATA<- as.data.table(nc_PAUCARPATA)
nc_PAUCARPATA[ident=='1.13-51-90',ident:='1.13.51-90']
nc_PAUCARPATA[ident=='1.12.47-1',ident:='1.13.47-1']
nc_PAUCARPATA[ident=='1.12.47-2',ident:='1.13.47-2']
nc_PAUCARPATA[ident=='1.12.47-3',ident:='1.13.47-3']
nc_PAUCARPATA[ident=='1.12.47-4',ident:='1.13.47-4']
nc_PAUCARPATA[ident=='1.12.47-5',ident:='1.13.47-5']
nc_PAUCARPATA[ident=='1.12.47-6',ident:='1.13.47-6']
nc_PAUCARPATA[ident=='1.12.47-7',ident:='1.13.47-7']
nc_PAUCARPATA[ident=='1.12.47-8',ident:='1.13.47-8']
nc_PAUCARPATA[ident=='1.12.47-9',ident:='1.13.47-9']
nc_PAUCARPATA[ident=='1.12.47-10',ident:='1.13.47-10']
nc_PAUCARPATA[ident=='1.12.47-11',ident:='1.13.47-11']
nc_PAUCARPATA[ident=='1.12.47-12',ident:='1.13.47-12']
nc_PAUCARPATA[ident=='1.12.47-13',ident:='1.13.47-13']
attack_PAUCARPATA <- attack[(1==attack$P & 13==attack$D),]
#Extrayendo solo los datos que necesito
attack_PAUCARPATA <- attack_PAUCARPATA[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
sapply(attack_PAUCARPATA,class)
attack_PAUCARPATA$ < - as.factor(attack_PAUCARPATA$I_TRIAT)
attack_PAUCARPATA$ <- as.factor(attack_PAUCARPATA$I_TRIAT)
attack_PAUCARPATA$I_TRIAT <- as.factor(attack_PAUCARPATA$I_TRIAT)
attack_PAUCARPATA$P_TRIAT<-as.factor(attack_PAUCARPATA$P_TRIAT)
casas_aqp<-as.data.table(casas_aqp)
DUPLICADOS<-casas_aqp[duplicated(casas_aqp$UNICODE)]
#Eliminando duplicados
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
#indice_dupli <- casas_aqp[which(duplicated(casas_aqp$UNICODE)),1]
#duplicados<-casas_aqp[casas_aqp$UNICODE %in% indice_dupli,]
#duplicados <- duplicados[order(duplicados$UNICODE),]
#casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
#indice_dupli <- casas_aqp_total[which(duplicated(casas_aqp_total$UNICODE)),1]
#duplicados<-casas_aqp_total[casas_aqp_total$UNICODE %in% indice_dupli,]
#duplicados <- duplicados[order(duplicados$UNICODE),]
# casas_aqp_total<-distinct(casas_aqp_total)
#casas_aqp_total[duplicated(casas_aqp_total)]
#casas_aqp_total[!duplicated(casas_aqp_total)]
#Bases utilizadas en el proceso
nc_polygon <- nc_melgar
nc_polygon <- nc_PAUCARPATA
old_casa_aqp <- casas_aqp
#Convirtiendo de factor a character o numero a caracter
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(nc_PAUCARPATA)
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(aqp_gps_block)
library(spatialEco)
library(sp)
library(dplyr)
library(data.table)
ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r/'
#Ruta
setwd(ruta_1)
#Leer los archivos
#Base de datos CONSOLIDADO GENERAL TODOS LOS DISTRITOS 2006-2015 hasta antes de Cerro Colorado
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2016.csv")
attack$UNICODE <- gsub('\\s+', '',attack$UNICODE)
casas_aqp<-read.csv("~/PETM-shiny/unicode_numberMzn/AREQUIPA_GPS_GOOGLE/AQP_GPS_GOOGLE_EARTH_PUNTOS_05_jun_2017.csv",sep = ',')
casas_aqp$UNICODE <- gsub('\\s+', '',casas_aqp$UNICODE)
nc_PAUCARPATA<-read.csv("~/Downloads/Paucarpata_Mz_26JUN2017 (1).csv",sep = ';')
nc_PAUCARPATA<- as.data.table(nc_PAUCARPATA)
nc_PAUCARPATA[ident=='1.13-51-90',ident:='1.13.51-90']
nc_PAUCARPATA[ident=='1.12.47-1',ident:='1.13.47-1']
nc_PAUCARPATA[ident=='1.12.47-2',ident:='1.13.47-2']
nc_PAUCARPATA[ident=='1.12.47-3',ident:='1.13.47-3']
nc_PAUCARPATA[ident=='1.12.47-4',ident:='1.13.47-4']
nc_PAUCARPATA[ident=='1.12.47-5',ident:='1.13.47-5']
nc_PAUCARPATA[ident=='1.12.47-6',ident:='1.13.47-6']
nc_PAUCARPATA[ident=='1.12.47-7',ident:='1.13.47-7']
nc_PAUCARPATA[ident=='1.12.47-8',ident:='1.13.47-8']
library(spatialEco)
library(sp)
library(dplyr)
library(data.table)
ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r/'
#Ruta
setwd(ruta_1)
#Leer los archivos
#Base de datos CONSOLIDADO GENERAL TODOS LOS DISTRITOS 2006-2015 hasta antes de Cerro Colorado
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2016.csv")
attack$UNICODE <- gsub('\\s+', '',attack$UNICODE)
#LEYENDO LOS ARCHIVOS QUE CONTIENEn LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/PETM-shiny/unicode_numberMzn/AREQUIPA_GPS_GOOGLE/AQP_GPS_GOOGLE_EARTH_PUNTOS_05_jun_2017.csv",sep = ',')
casas_aqp$UNICODE <- gsub('\\s+', '',casas_aqp$UNICODE)
#OBTENIENDO LAS BASES DE MANZANA  HUNTER ,JLB Y RIVERO ,LA JOYA ,SACHACA,UCHUMAYO,TIABAYA Y SOCABAYA
nc_PAUCARPATA<-read.csv("~/Downloads/Paucarpata_Mz_26JUN2017 (1).csv",sep = ';')
View(nc_PAUCARPATA)
nc_PAUCARPATA<- as.data.table(nc_PAUCARPATA)
nc_PAUCARPATA[ident=='1.13-51-90',ident:='1.13.51-90']
nc_PAUCARPATA[ident=='1.12.47-1',ident:='1.13.47-1']
nc_PAUCARPATA[ident=='1.12.47-2',ident:='1.13.47-2']
nc_PAUCARPATA[ident=='1.12.47-3',ident:='1.13.47-3']
nc_PAUCARPATA[ident=='1.12.47-4',ident:='1.13.47-4']
nc_PAUCARPATA[ident=='1.12.47-5',ident:='1.13.47-5']
nc_PAUCARPATA[ident=='1.12.47-6',ident:='1.13.47-6']
nc_PAUCARPATA[ident=='1.12.47-7',ident:='1.13.47-7']
nc_PAUCARPATA[ident=='1.12.47-8',ident:='1.13.47-8']
nc_PAUCARPATA[ident=='1.12.47-9',ident:='1.13.47-9']
nc_PAUCARPATA[ident=='1.12.47-10',ident:='1.13.47-10']
nc_PAUCARPATA[ident=='1.12.47-11',ident:='1.13.47-11']
nc_PAUCARPATA[ident=='1.12.47-12',ident:='1.13.47-12']
nc_PAUCARPATA[ident=='1.12.47-13',ident:='1.13.47-13']
View(nc_PAUCARPATA)
attack_PAUCARPATA <- attack[(1==attack$P & 13==attack$D),]
#Extrayendo solo los datos que necesito
attack_PAUCARPATA <- attack_PAUCARPATA[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_PAUCARPATA$I_TRIAT <- as.factor(attack_PAUCARPATA$I_TRIAT)
attack_PAUCARPATA$P_TRIAT<-as.factor(attack_PAUCARPATA$P_TRIAT)
casas_aqp<-as.data.table(casas_aqp)
DUPLICADOS<-casas_aqp[duplicated(casas_aqp$UNICODE)]
#Eliminando duplicados
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
nc_polygon <- nc_PAUCARPATA
old_casa_aqp <- casas_aqp
#Convirtiendo de factor a character o numero a caracter
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(aqp_gps_block)
