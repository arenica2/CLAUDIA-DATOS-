#Separando la fecha
fecha_roc_minsa$FECHA<-as.character( fecha_roc_minsa$FECHA, format="%Y%m%d" )
fecha_roc_minsa$FR_A<-format( fecha_roc_minsa$FECHA, format="%Y" )
fecha_roc_minsa$FR_M<-format( fecha_roc_minsa$FECHA, format="%m" )
fecha_roc_minsa$FR_D<-format( fecha_roc_minsa$FECHA, format="%d" )
#Merge entre "fecha_roc_minsa" y "rociador"
fecha<- merge(fecha_roc_minsa,rociador,by=codroc,all.x=T)
fecha<-fecha[,c(3,8,14:16,1,17,12,13)]
#---------------------------------------------------------------------#
#--------                  cons_roc_minsa                    ---------#
#---------------------------------------------------------------------#
#Se selecciona solo los que tienen "0" los demas son sumatorias de este.
cons_roc_minsa<-cons_roc_minsa[0==cons_roc_minsa$numrec,]
#Separando en "P", "D", "L" y "V"
cons_roc_minsa$P<-substr(cons_roc_minsa$codcnsldd,1,1)
cons_roc_minsa$D<-substr(cons_roc_minsa$codcnsldd,2,3)
cons_roc_minsa$L<-substr(cons_roc_minsa$codcnsldd,4,5)
cons_roc_minsa$V<-cons_roc_minsa$codigo
#Eliminado espacios en blanco
cons_roc_minsa$D <- gsub(" ","",cons_roc_minsa$D, fixed = T)
cons_roc_minsa$L <- gsub(" ","",cons_roc_minsa$L, fixed = T)
#Contruyendo UNICODE
cons_roc_minsa$UNICODE<-paste(cons_roc_minsa$P, cons_roc_minsa$D, cons_roc_minsa$L, cons_roc_minsa$V, sep = ".")
#Completando ciclos de rociado I y II
cons_roc_minsa$CICLO_ROCIADO<-substr(cons_roc_minsa$codcnsldd,8,8)#comprobado que salen bien
#Creando columna "MAS20TRI_IN" y "MAS20TRI_PE"
cons_roc_minsa$MAS20TRI_IN<- unlist(0)
cons_roc_minsa$MAS20TRI_PE<- unlist(0)
cons_roc_minsa[grepl("+",cons_roc_minsa$IN_TRI, fixed = TRUE),"MAS20TRI_IN"]<- 1
cons_roc_minsa[grepl("+",cons_roc_minsa$PE_TRI, fixed = TRUE),"MAS20TRI_PE"]<- 1
#Creando columnas de materiales en el INTRA y asignando su valor
cons_roc_minsa$IN_SIL<- unlist(0)
cons_roc_minsa$IN_NOB<- unlist(0)
cons_roc_minsa$IN_LAD<- unlist(0)
cons_roc_minsa$IN_ADO<- unlist(0)
cons_roc_minsa$IN_BLOQ<- unlist(0)
cons_roc_minsa[grepl("Sillar",cons_roc_minsa$IN_MAT, fixed = TRUE),"IN_SIL"]<- 1
cons_roc_minsa[grepl("Noble",cons_roc_minsa$IN_MAT, fixed = TRUE),"IN_NOB"]<- 1
cons_roc_minsa[grepl("Ladrillo",cons_roc_minsa$IN_MAT, fixed = TRUE),"IN_LAD"]<- 1
cons_roc_minsa[grepl("Adobe",cons_roc_minsa$IN_MAT, fixed = TRUE),"IN_ADO"]<- 1
cons_roc_minsa[grepl("Bloqueta",cons_roc_minsa$IN_MAT, fixed = TRUE),"IN_BLOQ"]<- 1
#Creando columnas de materiales en el PERI y asignando su valor
cons_roc_minsa$PE_SIL<- unlist(0)
cons_roc_minsa$PE_NOB<- unlist(0)
cons_roc_minsa$PE_LAD<- unlist(0)
cons_roc_minsa$PE_ADO<- unlist(0)
cons_roc_minsa$PE_BLOQ<- unlist(0)
cons_roc_minsa$PE_PIE<- unlist(0)
cons_roc_minsa[grepl("Sillar",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_SIL"]<- 1
cons_roc_minsa[grepl("Noble",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_NOB"]<- 1
cons_roc_minsa[grepl("Ladrillo",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_LAD"]<- 1
cons_roc_minsa[grepl("Adobe",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_ADO"]<- 1
cons_roc_minsa[grepl("Bloqueta",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_BLOQ"]<- 1
cons_roc_minsa[grepl("Piedra",cons_roc_minsa$PE_MAT, fixed = TRUE),"PE_PIE"]<- 1
#Creando columnas de animales en el TECHO y asignando su valor
cons_roc_minsa$TEC_CUY<- unlist(0)
cons_roc_minsa$TEC_CON<- unlist(0)
cons_roc_minsa$TEC_OVE<- unlist(0)
cons_roc_minsa$TEC_PER<- unlist(0)
cons_roc_minsa$TEC_AVE<- unlist(0)
cons_roc_minsa$TEC_GAT<- unlist(0)
cons_roc_minsa[grepl("Cuyes",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_CUY"]<- 1
cons_roc_minsa[grepl("Conejos",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_CON"]<- 1
cons_roc_minsa[grepl("Ovejas",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_OVE"]<- 1
cons_roc_minsa[grepl("Perros",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_PER"]<- 1
cons_roc_minsa[grepl("Aves",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_AVE"]<- 1
cons_roc_minsa[grepl("Gatos",cons_roc_minsa$AN_TEC, fixed = TRUE),"TEC_GAT"]<- 1
#Creando columnas de animales en el PATIO y asignando su valor
cons_roc_minsa$PAT_CUY<- unlist(0)
cons_roc_minsa$PAT_CON<- unlist(0)
cons_roc_minsa$PAT_OVE<- unlist(0)
cons_roc_minsa$PAT_PER<- unlist(0)
cons_roc_minsa$PAT_AVE<- unlist(0)
cons_roc_minsa$PAT_GAT<- unlist(0)
cons_roc_minsa[grepl("Cuyes",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_CUY"]<- 1
cons_roc_minsa[grepl("Conejos",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_CON"]<- 1
cons_roc_minsa[grepl("Ovejas",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_OVE"]<- 1
cons_roc_minsa[grepl("Perros",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_PER"]<- 1
cons_roc_minsa[grepl("Aves",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_AVE"]<- 1
cons_roc_minsa[grepl("Gatos",cons_roc_minsa$AN_PAT, fixed = TRUE),"PAT_GAT"]<- 1
#CONSOLIDADO FINAL
CONS_ROCIADO_2009_2015<- merge(cons_roc_minsa, fecha)
CONS_ROCIADO_2009_2015<- CONS_ROCIADO_2009_2015[,c(30,26:29,57:60,62,5:8,34:38,9,10,32,11,12,39:44,13,14,33,15,45:50,16,51:56,31,19:21)]# Tener cuidado cuando las tablas cambien de tamanio ya que esta en numeros
#Obteniendo solo las filas que son unicas, eliminando duplicados de filas
CONS_ROCIADO_2009_2015<- unique(CONS_ROCIADO_2009_2015)# se eliminaron 1274 registros
#Filtrando para que no se estC) buscando localidades que no estan en el estudio en ASA
filtro<-function(dat,dentro)
{
filtrado<-dat[(1==dat$P & 1==dat$D & is.element(dat$L,dentro)==TRUE),]
return(filtrado)
}
dentro<-c(7,8,13,14,22,23,25,26,27,29,34,36,39,42,44,45,71,77,78,81,82,83)
#Aplicando funcion filtro
tratadas_ASA<-filtro(CONS_ROCIADO_2009_2015,dentro)
#--------------------------------------------------------------------------------------
# Solo que tengan las columnas UNICODE, CICLO y STATUS
#--------------------------------------------------------------------------------------
#Cerradas
tdc_cnsldd<- read.dbf(path.expand("control/tdc_cnsldd.dbf"), as.is = TRUE)
#Renuente
tdr_cnsldd<- read.dbf(path.expand("control/tdr_cnsldd.dbf"), as.is = TRUE)
#Deshabitada
tdd_cnsldd<- read.dbf(path.expand("control/tdd_cnsldd.dbf"), as.is = TRUE)
#Local publico
tdp_cnsldd<- read.dbf(path.expand("control/tdp_cnsldd.dbf"), as.is = TRUE)
#Lote vacio
tdv_cnsldd<- read.dbf(path.expand("control/tdv_cnsldd.dbf"), as.is = TRUE)
#Utilizando la funcion CreateUnicode, para obtener los UNICODEs
tdc_cnsldd <- CreateUnicode(tdc_cnsldd)
tdr_cnsldd <- CreateUnicode(tdr_cnsldd)
tdd_cnsldd <- CreateUnicode(tdd_cnsldd)
tdp_cnsldd <- CreateUnicode(tdp_cnsldd)
tdv_cnsldd <- CreateUnicode(tdv_cnsldd)
# Obteniendo el ciclo de rociado real sacado de la columna CODCNSLDD
tdc_cnsldd$CICLO_ROCIADO<-substr(tdc_cnsldd$CODCNSLDD,8,8)
tdr_cnsldd$CICLO_ROCIADO<-substr(tdr_cnsldd$CODCNSLDD,8,8)
tdd_cnsldd$CICLO_ROCIADO<-substr(tdd_cnsldd$CODCNSLDD,8,8)
tdp_cnsldd$CICLO_ROCIADO<-substr(tdp_cnsldd$CODCNSLDD,8,8)
tdv_cnsldd$CICLO_ROCIADO<-substr(tdv_cnsldd$CODCNSLDD,8,8)
#Creando una columna STATUS
tdc_cnsldd$STATUS <- unlist("C")
tdr_cnsldd$STATUS <- unlist("R")
tdd_cnsldd$STATUS <- unlist("DES")
tdp_cnsldd$STATUS <- unlist("LP")
tdv_cnsldd$STATUS <- unlist("LV")
#Obteniendo solo columna que necesito
tdc_cnsldd <- tdc_cnsldd[, c(1:5,19,20)]
tdr_cnsldd <- tdr_cnsldd[, c(1:5,19,20)]
tdd_cnsldd <- tdd_cnsldd[, c(1:5,19,20)]
tdp_cnsldd <- tdp_cnsldd[, c(1:5,19,20)]
tdv_cnsldd <- tdv_cnsldd[, c(1:5,19,20)]
#Juntando
C_R <- merge(tdc_cnsldd,tdr_cnsldd, all = TRUE)
C_R_D <- merge(C_R,tdd_cnsldd, all = TRUE)
C_R_D_LP <- merge(C_R_D,tdp_cnsldd, all = TRUE)
C_R_D_LP_LV <-merge(C_R_D_LP,tdv_cnsldd, all = TRUE)
#Obteniendo registros unicos de todos los registros de Arequipa
C_R_D_LP_LV <- unique(C_R_D_LP_LV)
#Aplicando funcion filtro para obtener solo los datos del distrito ASA
statusMinsa<-filtro(C_R_D_LP_LV,dentro)
#Juntando con las tratadas
tratadas <- tratadas_ASA
tratadas$STATUS <- unlist("T")
tratadas <- tratadas[,c(1:5,21,32,48,52)]
tratadas <- unique(tratadas)
#Merge
statusMinsaASA <- merge(statusMinsa, tratadas, all = TRUE)
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#------------------       CONSOLIDADO GENERAL 2006 - 2015 MINSA        ------------------------
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#Leer datos
cons2006_2009 <- read.csv("UNION_ROCIADOS.csv")
#Eliminado los que tienen "0" en la columna "P"
cons2006_2009 <- cons2006_2009[!(cons2006_2009$P==0),]
#Eliminamos columna "ID"
cons2006_2009 <- subset(cons2006_2009, select = -ID)
#Cambiamos de nombre a la columna CICLO por CICLO_ROCIADO
colnames(cons2006_2009)[57] <- "CICLO_ROCIADO"
#Contruyendo UNICODE
cons2006_2009$UNICODE<-paste(cons2006_2009$P, cons2006_2009$D, cons2006_2009$L, cons2006_2009$V, sep = ".")
cons2006_2009 <- cons2006_2009[,c(62,1:61)] # Ordenando columnas
#Eliminar espacios en blanco de la columna UNICODE
cons2006_2009$UNICODE <- gsub(" ","",cons2006_2009$UNICODE, fixed = T)
#Convirtiendo todo los que tienen CICLO_ROCIADO = 0 a CICLO_ROCIADO = 1 (segC:n javier)
cons2006_2009$CICLO_ROCIADO[0 == cons2006_2009$CICLO_ROCIADO] <- 1
#Creando la columana STATUS
cons2006_2009$STATUS[cons2006_2009$Residual.T==1 | cons2006_2009$Residual.Rec==1] <- 1 #"T"
cons2006_2009$STATUS[cons2006_2009$Residual.R==1 & is.na(cons2006_2009$STATUS)] <- 2 #"R"
cons2006_2009$STATUS[cons2006_2009$Residual.C==1 & is.na(cons2006_2009$STATUS)] <- 3 #"C"
cons2006_2009$STATUS[cons2006_2009$Residual.D==1 & is.na(cons2006_2009$STATUS)] <- 4 #"DES"
#NOTA: El codigo "1.25.26.1769" tiene dos estados: "C" y "Rec", haremos valer el "Rec"
#--------------------------------------------------------------------------------------
#Completando STATUS con LP  y LV que se encuentran en el campo OBSERVACIONES
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & grepl("P.",cons2006_2009$OBSERVACIONES, fixed = TRUE)] <- 5 #"LP"
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & (grepl("V.",cons2006_2009$OBSERVACIONES, fixed = TRUE) | grepl("LOTE VACIO",cons2006_2009$OBSERVACIONES))] <- 6 #"LV"
#Si STATUS = NA y contiene la palabra "CONSTRUCCICN" o "NO SE ROCIO" ponemos C
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & (grepl("CONSTRUCCICN",cons2006_2009$OBSERVACIONES) | grepl("NO SE ROCIO",cons2006_2009$OBSERVACIONES))] <- 3 #"C"
#Si STATUS = NA y contiene la palabra "FUE ROCIADA"
cons2006_2009$STATUS[is.na(cons2006_2009$STATUS) & grepl("FUE ROCIADA",cons2006_2009$OBSERVACIONES)] <- 1 #"T"
#Viviendas que tienen dos UNICODEs
cons2006_2009$STATUS["1.7.25.193"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 183 es T
cons2006_2009$STATUS["1.7.25.236"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 194 es T
cons2006_2009$STATUS["1.7.41.199"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 200 es T
cons2006_2009$STATUS["1.7.41.238"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 237 es T
cons2006_2009$STATUS["1.7.41.292"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 291 es T
cons2006_2009$STATUS["1.7.8A.357"== cons2006_2009$UNICODE & 1==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 356 es T
cons2006_2009$STATUS["1.7.41.238"== cons2006_2009$UNICODE & 2==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 237 es T
cons2006_2009$STATUS["1.7.48C.15"== cons2006_2009$UNICODE & 2==cons2006_2009$CICLO] <- 1 #"T" # Vivienda 12 es T
#NOTA: Quedan 6 UNICODEs con NA en la columna STATUS
#------------------------------------------------------------------------------
#Creando la columna POS_CHIRI
cons2006_2009$POS_CHIRI[1==cons2006_2009$I_TRIAT | 1==cons2006_2009$P_TRIAT] <- 1
cons2006_2009$POS_CHIRI[is.na(cons2006_2009$POS_CHIRI)] <- 0
#Seleccionando solo las columna UNICODE, CICLO, STATUS y POS_CHIRI
status_cons2006_2009 <- subset(cons2006_2009, select = c(UNICODE, CICLO_ROCIADO, STATUS, POS_CHIRI))
status_cons2006_2009 <- unique(status_cons2006_2009)
#Utilizando funcion ElimDupliUxS()
c1_cons2006_2009 <- ElimDupliUxS(status_cons2006_2009[1 == status_cons2006_2009$CICLO_ROCIADO,])
c2_cons2006_2009 <- ElimDupliUxS(status_cons2006_2009[2 == status_cons2006_2009$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
status_cons2006_2009 <- rbind(c1_cons2006_2009, c2_cons2006_2009)
#----
#Acomodando los datos del consolidado 2009-2015 MINSA
#Creando la columna STATUS
CONS_ROCIADO_2009_2015$STATUS <- "T"
#Creando columna POS_CHIRI
CONS_ROCIADO_2009_2015$POS_CHIRI[is.na(CONS_ROCIADO_2009_2015$IN_TRI) & is.na(CONS_ROCIADO_2009_2015$PE_TRI)] <- 0
CONS_ROCIADO_2009_2015$POS_CHIRI[is.na(CONS_ROCIADO_2009_2015$POS_CHIRI)] <- 1
C_R_D_LP_LV$POS_CHIRI <- 0
#Seleccionando solo las columnas "UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"
status_T <- subset(CONS_ROCIADO_2009_2015, select = c("UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"))
status_C_R_D_LP_LV <- subset(C_R_D_LP_LV, select = c("UNICODE", "CICLO_ROCIADO", "STATUS", "POS_CHIRI"))
#Juntando consolidado 2009 - 2015
status_cons2009_2015 <- rbind(status_T, status_C_R_D_LP_LV)
#Registros unicos
status_cons2009_2015 <- unique(status_cons2009_2015)
#Cambiando el STATUS de letras (T, R, C, etct) por numeros de orden de prioridad (T=1, R=2, C=3, etc)
status_cons2009_2015$STATUS["T"==status_cons2009_2015$STATUS] <- 1
status_cons2009_2015$STATUS["R"==status_cons2009_2015$STATUS] <- 2
status_cons2009_2015$STATUS["C"==status_cons2009_2015$STATUS] <- 3
status_cons2009_2015$STATUS["DES"==status_cons2009_2015$STATUS] <- 4
status_cons2009_2015$STATUS["LP"==status_cons2009_2015$STATUS] <- 5
status_cons2009_2015$STATUS["LV"==status_cons2009_2015$STATUS] <- 6
#Utilizando funcion ElimDupliUxS()
c1_cons2009_2015 <- ElimDupliUxS(status_cons2009_2015[1 == status_cons2009_2015$CICLO_ROCIADO,])
c2_cons2009_2015 <- ElimDupliUxS(status_cons2009_2015[2 == status_cons2009_2015$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
status_cons2009_2015 <- rbind(c1_cons2009_2015, c2_cons2009_2015)
#-----
#CONSOLIDADO COMPLETO DESDE EL 2006 HASTA 2015 DEL MINSA CON LAS COLUMNAS: UNICODE, CICLO_ROCIADO, STATUS, POS_CHIRI
#Juntando consolidado final
STATUS_CONS_2006_2015 <- rbind(status_cons2006_2009, status_cons2009_2015) #181941
#Registros unicos
STATUS_CONS_2006_2015 <- unique(STATUS_CONS_2006_2015) # 181416, se eliminaron #525
#Utilizando funcion ElimDupliUxS()
c1_cons2006_2015 <- ElimDupliUxS(STATUS_CONS_2006_2015[1==STATUS_CONS_2006_2015$CICLO_ROCIADO,])
c2_cons2006_2015 <- ElimDupliUxS(STATUS_CONS_2006_2015[2==STATUS_CONS_2006_2015$CICLO_ROCIADO,])
#Juntando los dos ciclos en uno solo y SIN NINGUN dato duplicado
STATUS_CONS_2006_2015 <- rbind(c1_cons2006_2015, c2_cons2006_2015) #181245: se eliminaron 171 registros duplicados
#Cambiando los valores de la columna STATUS por T,R,C,DES,LP,LV para que no haya confusiones
STATUS_CONS_2006_2015$STATUS[1==STATUS_CONS_2006_2015$STATUS] <- "T"
STATUS_CONS_2006_2015$STATUS[2==STATUS_CONS_2006_2015$STATUS] <- "R"
STATUS_CONS_2006_2015$STATUS[3==STATUS_CONS_2006_2015$STATUS] <- "C"
STATUS_CONS_2006_2015$STATUS[4==STATUS_CONS_2006_2015$STATUS] <- "DES"
STATUS_CONS_2006_2015$STATUS[5==STATUS_CONS_2006_2015$STATUS] <- "LP"
STATUS_CONS_2006_2015$STATUS[6==STATUS_CONS_2006_2015$STATUS] <- "LV"
#Separando por ciclos para poder poner cambiar los nombres de los campos
c1_cons2006_2015 <- STATUS_CONS_2006_2015[1==STATUS_CONS_2006_2015$CICLO_ROCIADO,]
c2_cons2006_2015 <- STATUS_CONS_2006_2015[2==STATUS_CONS_2006_2015$CICLO_ROCIADO,]
#Cambiando los nombres de los campos dependiendo del ciclo al que pertenecen
colnames(c1_cons2006_2015) <- c("UNICODE", "C1" , "C1_STATUS", "C1_POS_CHIRI")
colnames(c2_cons2006_2015) <- c("UNICODE", "C2" , "C2_STATUS", "C2_POS_CHIRI")
#Cambiando el valor de la columna C2 por 1=Presencia o O=Ausencia
c2_cons2006_2015$C2 <- 1
#Juntando los dos ciclos en un solo registro
STATUS_CONS_2006_2015 <- merge(c1_cons2006_2015, c2_cons2006_2015, by = "UNICODE", all = TRUE)
#Ordenando por UNICODE
STATUS_CONS_2006_2015 <- STATUS_CONS_2006_2015[order(STATUS_CONS_2006_2015$UNICODE),]
#----------------------------------------------------------------------------------------
# Imprimiendo datos
#----------------------------------------------------------------------------------------
setwd("/home/gianfranco/Documentos/github/Participation/bd_minsa/resultados")
write.csv(STATUS_CONS_2006_2015,'STATUS_CONS_2006_2015.csv')
write.csv(CONS_ROCIADO_2009_2015,'CONS_ROCIADO_2009_2015.csv')
write.csv(statusMinsaASA,'statusMinsaASA.csv')
write.csv(tratadas_ASA,'tratadas_ASA.csv')
ruta_1 <- '~/bd_minsa/bd'
#-------------------------------------------------------------------
#============ Funcion CreateUnicode =========================================
# Solo si la data tiene la columna "CODCNSLDD"
#--------------------------------------------------------------------
CreateUnicode<-function(data) {
#Esta funcion retorna un data frame con los con el UNICODE
#
#ARGS
# data = La base donde se desea obtener el UNICODE
ruta_1 <- '~/bd_minsa/bd'
#-------------------------------------------------------------------
#============ Funcion CreateUnicode =========================================
# Solo si la data tiene la columna "CODCNSLDD"
#--------------------------------------------------------------------
CreateUnicode<-function(data) {
#Esta funcion retorna un data frame con los con el UNICODE
#
#ARGS
# data = La base donde se desea obtener el UNICODE
#
#RETURNS
# data = Con las columnas UNICODE, P, D, L, V al inicio del dataframe
#
#Separando en "P", "D", "L" y "V"
data$P<-substr(data$CODCNSLDD,1,1)
data$D<-substr(data$CODCNSLDD,2,3)
data$L<-substr(data$CODCNSLDD,4,5)
data$V<-data$CODIGO
#Eliminado espacios en blanco
data$D <- gsub(" ","",data$D, fixed = T)
data$L <- gsub(" ","",data$L, fixed = T)
#Contruyendo UNICODE
data$UNICODE<-paste(data$P, data$D, data$L, data$V, sep = ".")
#Ordenando Las columnas
n_col <- length(data)
data <- data[, c(n_col, n_col-4,n_col-3,n_col-2,n_col-1, 1:(n_col-5) )]
return(data)
}
#=========================================================================
#----------------------------------------------------------------------------
#============ Funcion ELIMINAR DUPLICADOS UNICODE X STATUS ==================
# Requerimientos:
#   - Las bases de datos deben contener las columna "UNICODE", "STATUS", "POS_CHIRI"
#--------------------------------------------------------------------
ElimDupliUxS<-function(data) {
#Esta funcion retorna un data frame con los datos de unicode UNICOS poniendo en prioridad el STATUS de las viviendas
#("T", "R", "C", "DES", "LP", "LV"), para con esto seleccionar el duplicado que debe quedar en el data.frame de respuesta
#
#ARGS
# data = Data frame conteniendo los datos
#RETURNS
# data_sindupli = Data frame sin duplicados
#
uni_dupli <- unique(data$UNICODE[which(duplicated(data$UNICODE))])
#Almacenamos en una variable los datos que NO contienen UNICODEs duplicados
#Obtenemos en un array todos los UNICODEs que son duplicados
#
data_sindupli <- data[!(data$UNICODE %in% uni_dupli),]
#Almacenamos en una variable todos los registros que SI son duplicados
data_condupli <- data[data$UNICODE %in% uni_dupli,]
variable <- data_condupli[1 == data_condupli$STATUS & 1 == data_condupli$POS_CHIRI,]
#Juntamos solo las viviendas sin duplicados, dependiendo de la prioridad del STATUS (T, R, C, DES, LP, LV)
i <- 1
#Almacenamos los datos sin duplicados
data_sindupli <- rbind(data_sindupli,variable)
#Actualizando variables
x <- data[data$UNICODE %in% uni_dupli,]
data_condupli <- data_condupli[data_condupli$UNICODE %in% uni_dupli,]
variable <- data_condupli[i == data_condupli$STATUS,]
}
return(data_sindupli)
}
#install.packages (b foreignb ) #Instalar el paquete que nos permite abrir archivos ".dbf"
#Ruta
setwd(ruta_1)
t_dist<- read.csv(path.expand("~/claudia codigos r/t_dist.csv"))#contiene los cC3digos y nombre de distritos, formulacion de insecticida
t_loc<- read.csv(path.expand("~/claudia codigos r/t_loc.csv"))#contiene nombre de localidades, codigo distrito, y nro de viv total de las loc
t_roc<- read.csv(path.expand("~/claudia codigos r/t_roc.csv"))#contiene cC3digos y nombres de los rociadores
#Obtenemos las bases que nos interesan
#Dando prioridad a los UNICODEs que son tratadas(STATUS=1) y positivas (POS_CHIRI=1)
while (length(uni_dupli)) {
#Trabajamos con los duplicados
uni_dupli <- setdiff(uni_dupli, variable$UNICODE)
#=========================================================================
i <- i+1
library(foreign) #Llamando al paquete
library(foreign) #Llamando al paquete
t_mat<- read.csv(path.expand("~/claudia codigos r/t_mat.csv"))#contiene el cC3digo y el nombre de los materiales de las viviendas
td_cnsldd<- read.csv(path.expand("~/claudia codigos r/td_cnsldd.csv"))#tabla de consolidaciC3n donde se encuentra la mayorC-a de la informaciC3n
th_cnsldd<- read.csv(path.expand("~/claudia codigos r/th_cnsldd.csv"))#contiene las fechas de rociado de las viviendas, ciclo de rociado
#Eliminando inconsistencias en bases foxpro
setwd ("~/CLAUDIA-DATOS-/claudia codigos r")
library(dplyr)
library(data.table)
library(dplyr)
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
library(spatialEco)
library(sp)
library(dplyr)
library(data.table)
#-RUTAS UTILIZADAS
ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r/'
#Ruta
setwd(ruta_1)
#Leer los archivos
#Base de datos CONSOLIDADO GENERAL TODOS LOS DISTRITOS 2006-2015
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
#LEYENDO LOS ARCHIVOS QUE CONTIENES LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/claudia codigos r/AREQUIPA_GPS_GOOGLE.csv")
casas_aqp_adicionadas <- read.csv("~/CLAUDIA-DATOS-/claudia codigos r/added_aqp_2006_2015.csv")
puntoscorregidos<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/puntos_corregidos/YARABAMBA_POINTS.csv")
nc_YARABAMBA<-read.csv ("~/CLAUDIA-DATOS-/Yarabamba_Mz_corregido.csv")
attack_Yarabamba <- attack[(1==attack$P & 28==attack$D),]
#Seleccionando solo los campos que necesito
attack_Yarabamba <- attack_Yarabamba[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
casas_aqp_total <-rbind(puntoscorregidos,casas_aqp_adicionadas)
indice_dupli <- casas_aqp[which(duplicated(casas_aqp$UNICODE)),1]
duplicados<-casas_aqp[casas_aqp$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
indice_dupli <- casas_aqp_total[which(duplicated(casas_aqp_total$UNICODE)),1]
duplicados<-casas_aqp_total[casas_aqp_total$UNICODE %in% indice_dupli,]
duplicados <- duplicados[order(duplicados$UNICODE),]
nc_polygon <- nc_melgar
nc_polygon <- nc_HUNTER
nc_polygon <- nc_JLB_RIVERO
nc_polygon <- nc_YARABAMBA
old_casa_aqp <- casas_aqp_total
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuarÃ¡ el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
diff1<-setdiff(attack_Yarabamba$UNICODE,aqp_gps_block$UNICODE) #  25viviendas
diff2<-setdiff(aqp_gps_block$UNICODE,attack_Yarabamba$UNICODE) # 176Viviendas
#Interseccion
interseption<-intersect(attack_Yarabamba$UNICODE, aqp_gps_block$UNICODE)#332
#Merge
YARABAMBA_gps_rociado <- merge(aqp_gps_block,attack_Yarabamba, all= TRUE, by = "UNICODE")
#Comprobando
aux1 <- attack_Yarabamba[attack_Yarabamba$UNICODE%in%diff1,]#39 observaciones
write.csv(aux1,"~/CLAUDIA-DATOS-/claudia codigos r/dif_roci_aqp/yarabamba_dif_sir_nogoo.csv",row.names = FALSE)
