aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(old_casa_aqp)
View(aqp_gps_block)
diff1<-setdiff(attack_HUNTER$UNICODE,aqp_gps_block$UNICODE) # 127 viviendas las que etsan en el ataque pero no tenemos puntos
diff2<-setdiff(aqp_gps_block$UNICODE,attack_HUNTER$UNICODE) # 609 viviendas que hay  en aqp_block
interseption<-intersect(attack_HUNTER$UNICODE, aqp_gps_block$UNICODE)#10365
HUNTER_gps_rociado <- merge(aqp_gps_block,attack_HUNTER, all= TRUE, by = "UNICODE")
faltantes<-HUNTER_gps_rociado[which(is.na(HUNTER_gps_rociado$LATITUDE))]
View(faltantes)
View(attack_HUNTER)
View(faltantes)
View(aqp_gps_block)
View(aqp_gps_block)
View(attack)
casas_aqp<-as.data.table(casas_aqp)
DUPLICADOS<-casas_aqp[duplicated(casas_aqp$UNICODE)]
#Eliminando duplicados
attack_HUNTER <- attack[(1==attack$P & 7==attack$D),]
#Seleccionando solo los campos que necesito
attack_HUNTER <- attack_HUNTER[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_HUNTER <- as.data.table(attack_HUNTER)
attack_HUNTER$UNICODE <- gsub("\\ ", "", attack_HUNTER$UNICODE)
View(attack)
View(attack_HUNTER)
View(faltantes)
attack_HUNTER <- attack[(1==attack$P & 7==attack$D),]
#Seleccionando solo los campos que necesito
attack_HUNTER <- attack_HUNTER[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_HUNTER <- as.data.table(attack_HUNTER)
attack_HUNTER$UNICODE <- gsub("\\s+", "", attack_HUNTER$UNICODE)
View(attack_HUNTER)
nc_polygon <- nc_HUNTER
View(nc_HUNTER)
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
casas_aqp<-read.csv("~/Downloads/AQP_GPS_GOOGLE_EARTH_PUNTOS.csv",sep = ';')
nc_HUNTER<-read.csv("~/CLAUDIA-DATOS-/Hunter_Mz_06FEB2017.csv")
nc_HUNTER[nc_HUNTER==" "]<-"NA"
View(attack_HUNTER)
attack_HUNTER <- attack[(1==attack$P & 7==attack$D),]
#Seleccionando solo los campos que necesito
attack_HUNTER <- attack_HUNTER[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_HUNTER <- as.data.table(attack_HUNTER)
attack_HUNTER$UNICODE <- gsub("\\s+", "", attack_HUNTER$UNICODE)
casas_aqp<-as.data.table(casas_aqp)
DUPLICADOS<-casas_aqp[duplicated(casas_aqp$UNICODE)]
#Eliminando duplicados
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
nc_polygon <- nc_HUNTER
old_casa_aqp <- casas_aqp
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
#--------JUNTANDO CONSOLIDADO CON CUADRAS -----
View(aqp_gps_block)
diff1<-setdiff(attack_HUNTER$UNICODE,aqp_gps_block$UNICODE) # 127 viviendas las que etsan en el ataque pero no tenemos puntos
diff2<-setdiff(aqp_gps_block$UNICODE,attack_HUNTER$UNICODE) # 609 viviendas que hay  en aqp_block
View(no_block)
interseption<-intersect(attack_HUNTER$UNICODE, aqp_gps_block$UNICODE)#10365
#Merge
HUNTER_gps_rociado <- merge(aqp_gps_block,attack_HUNTER, all= TRUE, by = "UNICODE")
faltantes<-HUNTER_gps_rociado[which(is.na(HUNTER_gps_rociado$LATITUDE))]
View(faltantes)
duplicados<-faltantes[duplicated(faltantes$UNICODE)]
View(duplicados)
aux1 <- attack_HUNTER[attack_HUNTER$UNICODE%in%diff1,]#131 VIVIENDAS
View(aux1)
aux2 <- HUNTER_gps_rociado[HUNTER_gps_rociado$UNICODE%in%diff1,]
aux3 <- HUNTER_gps_rociado[HUNTER_gps_rociado$UNICODE%in%diff2,]#609
aux3 <- HUNTER_gps_rociado[HUNTER_gps_rociado$UNICODE%in%diff2,]#597
idff<-setdiff(attack_HUNTER$UNICODE,casas_aqp_total$UNICODE)
baux<-attack_HUNTER[attack_HUNTER$UNICODE%in%idff,]#130
idff<-setdiff(attack_HUNTER$UNICODE,casas_aqp_total$UNICODE)
idff<-setdiff(attack_HUNTER$UNICODE,casas_aqp$UNICODE)
baux<-attack_HUNTER[attack_HUNTER$UNICODE%in%idff,]#130
View(baux)
View(no_block)
View(HUNTER_gps_rociado)
write.csv(HUNTER_gps_rociado,"~/CLAUDIA-DATOS-/claudia codigos r/MERGES_BLOCKS_GPS_ROCIADO/HUNTER_gps_rociado.csv", row.names = FALSE)
#Resultado de las viviendas de HUNTER que NO tienen numero de cuadra
write.csv(no_block,"~/CLAUDIA-DATOS-/claudia codigos r/no_blocks_arequipa/no_block_HUNTER.csv", row.names = FALSE)
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
#LEYENDO LOS ARCHIVOS QUE CONTIENEn LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/Downloads/AQP_GPS_GOOGLE_EARTH_PUNTOS.csv",sep = ';')
nc_melgar<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/Manzanas _Arequipa/Mariano Melgar/MARIANO MELGAR.csv")
attack_mm <- attack[(1==attack$P & 10==attack$D),]
#Seleccionando solo los campos que necesito
attack_mm <- attack_mm[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_mm <- attack_mm[,c("UNICODE", "I_TRIAT", "P_TRIAT", "FECHA", "CICLO","TRATADA","RENUENTE","CERRADA","DESHABITADA","LOCAL_PUBLICO","LOTE_VACIO")]
attack_mm <- as.data.table(attack_mm)
attack_mm$UNICODE <- gsub("\\s+", "", attack_mm$UNICODE)
View(attack_mm)
casas_aqp<-as.data.table(casas_aqp)
DUPLICADOS<-casas_aqp[duplicated(casas_aqp$UNICODE)]
#Eliminando duplicados
casas_aqp<-casas_aqp[!duplicated(casas_aqp$UNICODE), ]
nc_polygon <- nc_melgar
old_casa_aqp <- casas_aqp
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
#--------JUNTANDO CONSOLIDADO CON CUADRAS -----
View(no_block)
View(nc_polygon)
View(no_block)
View(no_block)
diff1<-setdiff(attack_mm$UNICODE,aqp_gps_block$UNICODE) # 28 viviendas
diff2<-setdiff(aqp_gps_block$UNICODE,attack_mm$UNICODE) # 3172
mmelgar_gps_rociado <- merge(aqp_gps_block,attack_mm, all= TRUE, by = "UNICODE")
View(mmelgar_gps_rociado)
View(no_block)
#Comprobando
attack<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/ATTACK_2006_2015.csv")
#LEYENDO LOS ARCHIVOS QUE CONTIENEn LOS GP/S DE CASAS NORMALES Y ADICIONADAS .
casas_aqp<-read.csv("~/Downloads/AQP_GPS_GOOGLE_EARTH_PUNTOS.csv",sep = ';')
View(aux)
nc_HUNTER<-read.csv("~/CLAUDIA-DATOS-/Hunter_Mz_06FEB2017.csv")
nc_HUNTER[nc_HUNTER==" "]<-"NA"
nc_melgar<-read.csv("~/CLAUDIA-DATOS-/claudia codigos r/Manzanas _Arequipa/Mariano Melgar/MARIANO MELGAR.csv")
View(nc_polygon)
attack_mm <- attack[(1==attack$P & 10==attack$D),]
View(attack_mm)
nc_polygon <- nc_melgar
View(nc_HUNTER)
View(nc_melgar)
View(nc_HUNTER)
View(nc_melgar)
View(nc_HUNTER)
View(nc_melgar)
old_casa_aqp <- casas_aqp
#Convirtiendo de factor a character o numero a caracter
nc_polygon$ident <- as.character(nc_polygon$ident)
nc_polygon$long <- as.character(nc_polygon$long)
nc_polygon$lat <- as.character(nc_polygon$lat)
old_casa_aqp$D <- as.character(old_casa_aqp$D)
old_casa_aqp$L <- as.character(old_casa_aqp$L)
#Creando columna para el numero de localidad y de cuadra
nc_polygon$num_distrito <- NA
nc_polygon$num_localidad <- NA
nc_polygon$num_cuadra <- NA
#Creando variables
x<-NULL
y<-NULL
distrito <- 0
localidad <- 0
aqp_gps_block <- data.frame()
aux <- data.frame()
no_block <- data.frame()#Alamcenaremos los que no tienen cuadra
inicio <-1 #si tiene 1 es por que es un primer elemento
aux_null <- 0 #Si es 0 significa que si existen datos en la variable "aux"
n_row <- nrow(nc_polygon)+1
i<-1 #Controlador del bucle
while (i <= n_row) {
if ( !is.na(nc_polygon$long[i]) && !(nc_polygon$long[i]==" ") ) {
#Acumulando los "x" e "y"
x<-c(x,nc_polygon$long[i])#Longitud
y<-c(y,nc_polygon$lat[i])#Latitud
} else{
if(1!=inicio){
#Pregunta si tienen el mismo distrito y localidad, si no entonces se extrae otra porcion de viviendas
if (distrito!=nc_polygon$num_distrito[indice] | localidad!=nc_polygon$num_localidad[indice]) {
no_block <- rbind(no_block,aux)
aux <- old_casa_aqp[nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L,]
if ( nrow(aux)!=0 ) {
aux$block <- NA
old_casa_aqp <- old_casa_aqp[!(nc_polygon$num_distrito[indice]== old_casa_aqp$D & nc_polygon$num_localidad[indice]== old_casa_aqp$L),]
aux_null <- 0
}
else {
aux_null <- 1
}
} else {
if (nrow(aux)==0){
aux_null <- 1
}
}
if ( aux_null == 0 ) {
for (j in 1:nrow(aux)) {
#Utilizando la funcion "point.in.polygon" para ver si el punto esta dentro del poligono
opcion <- point.in.polygon(aux$LONGITUDE[j],aux$LATITUDE[j], x,y)
if (0!=opcion) {
aux$block[j] <- nc_polygon$num_cuadra[indice]
}
}
#Almacenando los puntos que tienen numero de cuadra en una base de datos final
aqp_gps_block <- rbind(aqp_gps_block,aux[!is.na(aux$block),])
#Alamcenando los codigos que aun falta poner cuadra
aux <- aux[is.na(aux$block),]
#Almacenando distrito y localidad
distrito <- nc_polygon$num_distrito[indice]
localidad <- nc_polygon$num_localidad[indice]
}
#Inicializando los puntos del poligono
x<-NULL
y<-NULL
}
if (i < n_row ) {
#Separar donde encuentre el caracter "-"
split_ident <- unlist(strsplit(nc_polygon$ident[i], "-", fixed = TRUE))
#Si es distinto a NA continuará el ciclo, pueden haber nombre que NO contengan el caracter "-"
if (!is.na(split_ident[2])) {
#Revisando si existe una letra
letter_number <- regexpr("[A-Za-z]", split_ident[2])
#Pregunta si el segundo argumento es numero
if (  letter_number[1]==-1 ) {
#Separando el codigo por cada punto
codigo <- unlist(strsplit(split_ident[1], ".", fixed = TRUE))
#Almacenando numero de distrito
nc_polygon$num_distrito[i] <- codigo[2]
#Almacenando numero de localidad
nc_polygon$num_localidad[i] <- codigo[3]
#Almacenando el numero de cuadra
nc_polygon$num_cuadra[i] <- split_ident[2]
#Almacenando indice
indice <- i
inicio <- 0
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
inicio <-1
}
}
} else {
while (!is.na(nc_polygon$long[i+1]) && !(nc_polygon$long[i+1]==" ") ) {
i<-i+1
}
inicio <-1
#aux_null <- 0
}
}
}
i<-i+1
}
View(no_block)
View(aqp_gps_block)
View(aux)
diff1<-setdiff(attack_mm$UNICODE,aqp_gps_block$UNICODE) # 28 viviendas
diff2<-setdiff(aqp_gps_block$UNICODE,attack_mm$UNICODE) # 3172
#Interseccion
interseption<-intersect(attack_mm$UNICODE, aqp_gps_block$UNICODE)#9703
#Merge
mmelgar_gps_rociado <- merge(aqp_gps_block,attack_mm, all= TRUE, by = "UNICODE")
#Comprobando
aux1 <- attack_mm[attack_mm$UNICODE%in%diff1,]#35
aux2 <- mmelgar_gps_rociado[mmelgar_gps_rociado$UNICODE%in%diff1,]
aux3 <- mmelgar_gps_rociado[mmelgar_gps_rociado$UNICODE%in%diff2,]#3172
View(aux3)
