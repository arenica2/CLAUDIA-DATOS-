{
    "collab_server" : "",
    "contents" : "#Requerimientos\n#- Que las casas adicionadas esten en la misma base que las casas a la que corresponden\n#- Tener columnas: UNICODE, V\n\n#-RUTAS UTILIZADAS\n  ruta_1 <- '~/CLAUDIA-DATOS-/claudia codigos r'\n\n#Ruta\n  setwd(ruta_1)\n\nlibrary(data.table)  \n  \n#Leer los archivos\n  attack_2006_2015 <- read.csv(\"~/CLAUDIA-DATOS-/claudia codigos r/ATTACK_2006_2015/attack_2006_2015.csv\")\n  gps_aqp<-read.csv(\"~/CLAUDIA-DATOS-/AQP_GPS_GOOGLE_18_02_2017/AQP_GPS_GOOGLE_corregido.csv\",sep = \",\")\n  gps_aqp<-as.data.table(gps_aqp)\n  gps_aqp<-gps_aqp[D==7|D==8|D==9|D==13|D==18|D==23|D==24|D==25|D==1|D==4|D==3|D==10|D==11|D==12|D==28|D==5]\n  \n  a?adidas_2006_2015<-read.csv(\"~/CLAUDIA-DATOS-/claudia codigos r/added_aqp_2006_2015.csv\")\n\naqp_completo<-rbind(gps_aqp,a?adidas_2006_2015)\n  \n#haciendo el merge para ver cuantas caasas regulares no tienen gps despues de haber \n#unido todos los gps con las adicionales .\naux<-merge(attack_2006_2015,aqp_completo,by = \"UNICODE\",all.x = TRUE)\nlength(which(is.na(aux$LATITUDE)))\n\nwrite.csv(aux,\"casasregullressingps.csv\",row.names = FALSE)\n\nrociado_gps<-merge(attack_2006_2015,gps_aqp,by = \"UNICODE\",all.x = TRUE)\nrociado_gps<-as.data.table(rociado_gps)\nrociado_gps$LATITUDE<-as.character(rociado_gps$LATITUD)\n\n\n\nwrite.csv(rociado_gps,\"casas_rociado_gps.csv\",row.names =FALSE)\n\n#escogiendo variablesque nos interesan y cambiando los nombres a las otras columnas  \nlength(which(is.na(rociado_gps$LATITUDE)))     #5865 observations with no coordinates\ncasas_singps<- (which(is.na(rociado_gps$LATITUDE)))\ncasas_singps<-as.data.frame(casas_singps)\nmissing.gps <- missing.gps[which(is.na(rociado_gps$LATITUDE))]   \n missing.gps<-as.data.frame(missing.gps)\n  \n\nvarstokeep <- c(\"UNICODE\", \"P.y\",\"D.y\",\"L.y\",\"V.y\",\"FECHA\", \"CICLO\",\"TRATADA\",\"RENUENTE\",\"CERRADA\",\"DESHABITADA\",\"LOCAL_PUBLICO\",\"LOTE_VACIO\",\"LATITUDE\",\"LONGITUDE\")\nrociado_gps <- rociado_gps[,varstokeep]\nrociado_gps<-as.data.table(rociado_gps) \n  #changed columns names \n  setnames(rociado_gps,\"P.y\",\"P\")\n  setnames(rociado_gps,\"D.y\",\"D\")\n  setnames(rociado_gps,\"L.y\",\"L\")\n  setnames(rociado_gps,\"V.y\",\"V\") \n\n           \n  #Convertir a character\n  attack_2006_2015$UNICODE <- as.character(attack_2006_2015$UNICODE)\n  attack_2006_2015$L <- as.character(attack_2006_2015$L)\n  attack_2006_2015$V <- as.character(attack_2006_2015$V)\n  gps_aqp$UNICODE <- as.character(gps_aqp$UNICODE)\n  gps_aqp$L <- as.character(gps_aqp$L)\n  gps_aqp$V <- as.character(gps_aqp$V)\n\n#Seleccionar solo los datos unicos\n  rociado_gps_unicos <- attack_2006_2015[which(!duplicated(attack_2006_2015$UNICODE)),]\n  data <- rociado_gps_unicos\n  \n#Selecionando solo columnas que nos importan\n  data <- data[,c(\"UNICODE\",\"P\",\"D\",\"L\",\"V\")]  \n#Agregamos una columna para almacenar la letra de las adicionales\n  data$ADDED <- NA\n  \n#Obtener todos las viviendas adicionadas que no tienen gps\n  n_row <- nrow(data)  \n\n  for (i in 1:n_row) {\n    #Solo los que no tienen dato\n    if (is.na(data$V[i])) {\n      #Separando UNICODE\n      split_unicode <- unlist(strsplit(data$UNICODE[i], \".\", fixed = TRUE))\n      \n      letter_number <- regexpr(\"[A-Z]\", split_unicode[4])\n      #Pregunta si el segundo argumento es numero\n      if (  letter_number[1]!=-1 ) {\n        data$P[i] <- split_unicode[1]\n        data$D[i] <- split_unicode[2]\n        data$L[i] <- split_unicode[3]\n        viv <- gsub(\"([A-Z])\", \"\",split_unicode[4])\n        \n        num1<-nchar(viv)\n        num2<-nchar(split_unicode[4])\n        \n        data$V[i] <- substring(split_unicode[4], 1, num1)\n        data$ADDED[i] <- substring(split_unicode[4], num2)\n      }\n    }\n  }\n  \n#Buscamos todas las adicionadas, basandonos en la columna ADDED\n  data_added <- data[!is.na(data$ADDED),]\n#Agregando un campo de UNICODE_FALSO\n  data_added$UNICODE_FALSO <- NA\n  \n  n_row<-nrow(data_added) \n  for (i in 1:n_row) {\n    #Creamos un unicode falso para poder obtener los GPS\n    data_added$UNICODE_FALSO[i] <- paste(data_added$P[i],data_added$D[i],data_added$L[i],data_added$V[i], sep = \".\")\n  }\n#Elimino campos que me causaran inconveniente al hacer el MERGE\n  data_added<- data_added[,c(\"UNICODE\",\"ADDED\",\"UNICODE_FALSO\")]\n  \n#Haciendo MERGE con la base principal \"gps_aqp\"\n  data_added <- merge(data_added, gps_aqp, by.x = \"UNICODE_FALSO\", by.y = \"UNICODE\")\n\n  #NOTA: Por el momento al realizar el merge hay 42 viviendas que no tienen su dato correspondiente\n  #en la base \"gps_aqp\" pero si esta en \"aqp_rociado\" pero no tienen GPS por eso por el momento no \n  #lo tomaremos en cuenta, para un futuro si desean tener todas las adicionadas tienen que solucionar\n  #esos inconvenientes poniendoles GPS\n  \n#Eliminar la columna UNICODE_FALSO\n  data_added <- data_added[,-1]\n#Contruyendo el numero de vivienda que corresponde realmente \"V + ADDED\"\n  n_row<-nrow(data_added) \n  for (i in 1:n_row) {\n    #Creamos un unicode falso para poder obtener los GPS\n    data_added$V[i] <- paste(data_added$V[i], data_added$ADDED[i] ,sep = \"\")\n  }\n#Eliminando la columna ADDED\n  data_added<- data_added[,-2]\n \n  data_unicos <- data_added[which(!duplicated(data_added$UNICODE)),]\n  data <- data_unicos \n   \n#--------------------------------------------------------------------  \n#Imprimiendo Resultados\n#--------------------------------------------------------------------\n  \n  #Resultado de las viviendas adicionadas\n  write.csv(data_added,\"added_aqp_2006_2015.csv\",row.names = FALSE)\n  ",
    "created" : 1487394198161.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3659420666",
    "id" : "D66EE977",
    "lastKnownWriteTime" : 1486591096,
    "last_content_update" : 1487395401290,
    "path" : "~/CLAUDIA-DATOS-/claudia codigos r/CODIGOS APLICACION/put_gps_added1.R",
    "project_path" : "claudia codigos r/CODIGOS APLICACION/put_gps_added1.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}